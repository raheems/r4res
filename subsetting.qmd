# Subsetting

If you have a selection of items in a basket, selecting a few of the items from the basket is subsetting. You can also call it selecting a subset. Often we need to select a portion of the elements in a vector, or a few columns in a data frame, or a subset of the rows and columns based on come conditions. Subsetting is an essential skill to master for every data professional.

Subsetting in R is very fast. For some, it may feel natural. For others it may feel intimidating at first. But trust me--its easy if you are patient. Lets start with how to subset an atomic vector.

## Subsetting Atomic Vector

### Using integer position

There are six ways to subset an atomic vector. However, we will focus on two that you can reuse for other data types.

First, there are three subsetting operators. These are `[`, `[[`, and `$`. Let's see an example.

```{r}
my_vec = c(10.1, 2.2, 32.3, 5.4)
```
The number after the decimals indicate the actual position of the elements. If we want to select the first element of the vector, we use the vector name and within the bracket, put the position of the element. `my_vec[1]` will give your the first element of `my_vec`.

```{r}
my_vec[1]
```

Notice that we used 1 to identify the first element. In R, the index starts at 1. In many popular programming languages such as Python and Java, the index starts at zero. Just keep this in mind.

To extract the second element, use `[2]`

```{r}
my_vec[2]
```

How about extracting multiple elements? Not a problem. Just combine the element's positions with the `c()` function and wrap that with the subsetting operator `[` on the `my_vec` object

```{r}
# extract the first and third element
my_vec[c(1, 3)] # subsetting with integer position
```

To exclude an element at a particular position, negate the function as `-c()`

```{r}
# exclude the second element
my_vec[-c(2)]
```

However, we cannot include and exclude at the same time.

```{r, eval = FALSE}
# keep first element but exclude the second
my_vec[c(1, -2)] # only 0's may be mixed with negative subscripts
```

### Using logical vectors

We want to select all the elements that are bigger than 9. First we create a logical vector that satisfies our conditions

```{r}
my_vec > 9

# check the type of the resulting vector
typeof(my_vec > 9)
```
Now apply the resulting logical vector to subsetting from `my_vec` to return only the elements where the condition (greater than 9) is TRUE

```{r}
my_vec[my_vec > 9] # subsetting with logical vector
```

::: {.callout-tip}

## Use logical vector instead of for loop

Using logical vector to subsetting is extremely fast. In R, try to avoid for loops. Instead, use logical vector for vectorized computation.

:::

## Subsetting Matrix

Since matrix is a two-dimensional object which has a row and a column, the subsetting must utilize its dimensions.

Let us create a matrix `my_mat` whose elements 1:50 are arranged in 10 rows and 5 columns.

```{r}
my_mat = matrix(1:50, nrow = 10, ncol = 5)
my_mat
```
First element is 1 which is located at the first-row and first-column. That is, the location of the first element is [1, 1], where the first element represents the row-position, and the second element represents the column-position.

```{r}
# extract the first element
my_mat[1,1]

```

### Subsetting entire row of a matrix

```{r}
# subset the first row
my_mat[1, ]
```


### Subsetting multiple rows of a matrix

```{r}
# subset rows 1, 2, and 4 and return all columns
my_mat[c(1, 2, 4), ]
```

### Subsetting a column

```{r}
# subset the second columns and keep values in all rows
my_mat[ , 2]

```


## Subsetting Data Frame


Data frames are created using the `data.frame()` function by supplying a list of columns. data.frames, as it is typically referred to are of list data type with one important distinction. List can have elements of unequal length. In data.frame, all the elements must have the same length to make the data.frame a true rectangular array. 


```{r}
x = c(1, 2, 3)
my_list = list(
  serial = 1:5,
  age = c(10, 11, 20, 30, 32), 
  sex = c('M', 'F', 'F', 'M', 'M')
)
df = data.frame(my_list)

df
```

If you look at the data type for `df` using `typeof(df)`, you will see its a list.

```{r}
typeof(df)
```

To view the structure of `df` object

```{r}
str(df)
```

To select the columns, we use `$` operator to subset a column

```{r}
df$age
df$serial
df$sex
```

The data type of the extracted column `age` is `r typeof(df$age)`. Likewise, the data type of `sex` is `r typeof(df$sex)`.

### Selecting rows using conditions

Select all rows where the sex is male

```{r}
df$sex
df$sex == 'M'

# subset the males
df[df$sex == 'M', ]
```

If you want to select only age and sex of the data frame where `sex = M` 

```{r}
df[df$sex == 'M', c('age', 'sex')]
```

Alternatively we could use the column position integers to select the columns

```{r}
df[df$sex == 'M', c(2, 3)]
```


## Subsetting List

```{r}
# prints the list
my_list
```

List can be subsetted using the `$` operator too.

```{r}
my_list$age
```

Or alternatively `[` or the `[[` operator can be used depending on your preference and exactly what you want to extract.

```{r}

# extracts the first item of the list
my_list[1]

# extracts the elements of the first item of the list
my_list[[1]]

```
You can also use the name of the vector within the list to extract the list item

```{r}
my_list['age']
```

To extract the second element of the named vector `age`

```{r}
my_list[['age']][2]
```


You can also use the `[[` operator on data frame to extract the items and the elements within the items of a data frame. This is because the data frame is a collection of atomic vectors and its data type is `list`.

```{r}
typeof(df)
```

## Assigning values with Subsetting

Subsetting can be used to assign new values. This is also known as 'setting' a value


### Exercise

1. Create a matrix object and explore its attributes. What difference do you see from the attributes of a data frame?

```{r, eval = FALSE}
x = matrix(1:10, ncol=2)
x
attributes(x)
```

2. Create a list object and explore its attributes.

3. Create a data frame object and explore its attributes.

# References {.unnumbered}

::: {#refs}
:::


